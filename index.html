<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline'; connect-src 'self' https://api.github.com; style-src 'self' 'unsafe-inline'; img-src 'self' data:;">
    <title>Simple GitHub Writer</title>
    <link rel="icon" href="data:,">
    <style>
        * {
            box-sizing: border-box;
        }

        body {
            font-family: Arial, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
            background-color: #f0f0f0;
        }

        .container {
            background: white;
            border-radius: 10px;
            padding: 30px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            max-width: 400px;
            width: 100%;
        }

        h1 {
            margin-top: 0;
            color: #333;
            font-size: 1.5rem;
            text-align: center;
        }

        .info {
            background: #e3f2fd;
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 20px;
            font-size: 0.9rem;
            color: #333;
        }

        .info strong {
            display: block;
            margin-bottom: 5px;
        }

        button {
            width: 100%;
            padding: 15px;
            background-color: #2196F3;
            color: white;
            border: none;
            border-radius: 5px;
            font-size: 1rem;
            cursor: pointer;
            margin-bottom: 10px;
        }

        button:hover {
            background-color: #1976D2;
        }

        button:active {
            transform: scale(0.98);
        }

        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
            opacity: 0.6;
        }

        .status {
            text-align: center;
            margin-top: 15px;
            padding: 10px;
            border-radius: 5px;
            font-size: 0.9rem;
        }

        .status.success {
            background-color: #d4edda;
            color: #155724;
        }

        .status.error {
            background-color: #f8d7da;
            color: #721c24;
        }

        .status.info {
            background-color: #d1ecf1;
            color: #0c5460;
        }

        /* Modal Dialog Styles */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal-content {
            background: white;
            border-radius: 10px;
            padding: 30px;
            max-width: 400px;
            width: 90%;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        }

        .modal-content h2 {
            margin-top: 0;
            color: #333;
            font-size: 1.3rem;
        }

        .modal-content p {
            color: #666;
            margin-bottom: 15px;
        }

        .modal-content input {
            width: 100%;
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 1rem;
            margin-bottom: 20px;
            box-sizing: border-box;
        }

        .modal-content input:focus {
            outline: none;
            border-color: #2196F3;
        }

        .modal-buttons {
            display: flex;
            gap: 10px;
        }

        .modal-btn-primary, .modal-btn-secondary {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 5px;
            font-size: 1rem;
            cursor: pointer;
        }

        .modal-btn-primary {
            background-color: #2196F3;
            color: white;
        }

        .modal-btn-primary:hover {
            background-color: #1976D2;
        }

        .modal-btn-secondary {
            background-color: #f0f0f0;
            color: #333;
        }

        .modal-btn-secondary:hover {
            background-color: #e0e0e0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>GitHub Data Writer</h1>
        
        <div class="info">
            <strong>Repository:</strong>
            mikelawtime-a11y/lawtime
        </div>

        <button id="btnAddItem">Add Test Item to GitHub</button>
        <button id="btnChangeToken" style="background-color: #607D8B;">Change Token</button>

        <div class="status" id="status" style="display: none;"></div>
    </div>

    <!-- Custom Modal Dialog -->
    <div id="modal" class="modal" style="display: none;" role="dialog" aria-modal="true" aria-labelledby="modalTitle" aria-describedby="modalMessage">
        <div class="modal-content">
            <h2 id="modalTitle">Enter Information</h2>
            <p id="modalMessage"></p>
            <input type="text" id="modalInput" placeholder="" aria-required="true">
            <div class="modal-buttons">
                <button id="modalOk" class="modal-btn-primary">OK</button>
                <button id="modalCancel" class="modal-btn-secondary">Cancel</button>
            </div>
        </div>
    </div>

    <script src="encryption.js"></script>
    <script>
        // SECURITY: Enforce HTTPS in production
        if (location.protocol !== 'https:' && location.hostname !== 'localhost' && location.hostname !== '127.0.0.1') {
            location.replace(`https:${location.href.substring(location.protocol.length)}`);
        }

        const GITHUB_OWNER = 'mikelawtime-a11y';
        const GITHUB_REPO = 'datarepo';
        
        // Generate file path based on current year and month (e.g., 202512.json for Dec 2025)
        function getGitHubPath() {
            const now = new Date();
            const year = now.getFullYear();
            const month = String(now.getMonth() + 1).padStart(2, '0');
            return `${year}${month}.json`;
        }
        
        const TOKEN_EXPIRY_DAYS = 7; // Token expires after 7 days (change to 30 for a month)
        const STATUS_HIDE_DELAY = 5000; // milliseconds
        const INACTIVITY_TIMEOUT = 15 * 60 * 1000; // 15 minutes

        // Encapsulate sensitive data in a module pattern
        const AppState = (() => {
            let _token = null;
            let _password = null;
            let _events = {};
            let _inactivityTimer = null;
            
            return {
                getToken: () => _token,
                setToken: (val) => {
                    _token = val;
                    resetInactivityTimer();
                },
                getPassword: () => _password,
                setPassword: (val) => {
                    _password = val;
                    resetInactivityTimer();
                },
                getEvents: () => _events,
                setEvents: (val) => {
                    _events = val;
                },
                clearCredentials: () => {
                    _token = null;
                    _password = null;
                },
                getInactivityTimer: () => _inactivityTimer,
                setInactivityTimer: (val) => {
                    _inactivityTimer = val;
                }
            };
        })();
        
        // Session timeout - auto-lock after inactivity
        function resetInactivityTimer() {
            clearTimeout(AppState.getInactivityTimer());
            const timer = setTimeout(() => {
                AppState.clearCredentials();
                showStatus('üîí Session locked due to inactivity', 'info', true);
                // Disable buttons
                document.getElementById('btnAddItem').disabled = true;
                document.getElementById('btnChangeToken').textContent = 'Unlock / Change Token';
            }, INACTIVITY_TIMEOUT);
            AppState.setInactivityTimer(timer);
        }
        
        // Helper function for rate limit handling (DRY principle)
        function handleRateLimitResponse(response) {
            const resetTime = response.headers.get('X-RateLimit-Reset');
            const resetDate = resetTime ? new Date(resetTime * 1000).toLocaleTimeString() : 'soon';
            return `‚ö† Rate limit exceeded. Try again after ${resetDate}`;
        }
        
        // Custom modal dialog helper
        function showModal(title, message, placeholder = '', isPassword = false) {
            resetInactivityTimer(); // Reset timer on user interaction
            return new Promise((resolve) => {
                const modal = document.getElementById('modal');
                const modalTitle = document.getElementById('modalTitle');
                const modalMessage = document.getElementById('modalMessage');
                const modalInput = document.getElementById('modalInput');
                const modalOk = document.getElementById('modalOk');
                const modalCancel = document.getElementById('modalCancel');
                const modalContent = modal.querySelector('.modal-content');
                
                // Store previously focused element to restore later
                const previouslyFocused = document.activeElement;
                
                modalTitle.textContent = title;
                modalMessage.textContent = message;
                modalInput.value = '';
                modalInput.placeholder = placeholder;
                modalInput.type = isPassword ? 'password' : 'text';
                modal.style.display = 'flex';
                
                // Focus input after modal is visible
                setTimeout(() => modalInput.focus(), 0);
                
                // Fix P1: Focus trap - keep focus within modal
                const focusableElements = [modalInput, modalOk, modalCancel];
                const firstFocusable = focusableElements[0];
                const lastFocusable = focusableElements[focusableElements.length - 1];
                
                const handleTabKey = (e) => {
                    if (e.key === 'Tab') {
                        if (e.shiftKey) {
                            if (document.activeElement === firstFocusable) {
                                lastFocusable.focus();
                                e.preventDefault();
                            }
                        } else {
                            if (document.activeElement === lastFocusable) {
                                firstFocusable.focus();
                                e.preventDefault();
                            }
                        }
                    }
                };
                
                const cleanup = () => {
                    modal.style.display = 'none';
                    modalOk.onclick = null;
                    modalCancel.onclick = null;
                    modalInput.onkeydown = null;
                    modal.onclick = null;
                    document.removeEventListener('keydown', handleTabKey);
                    // Restore focus to previously focused element
                    if (previouslyFocused) {
                        previouslyFocused.focus();
                    }
                };
                
                // Fix P1: Click outside modal content to close
                modal.onclick = (e) => {
                    if (e.target === modal) {
                        cleanup();
                        resolve(null);
                    }
                };
                
                // Prevent clicks inside modal content from closing
                modalContent.onclick = (e) => {
                    e.stopPropagation();
                };
                
                modalOk.onclick = () => {
                    const value = modalInput.value;
                    cleanup();
                    resolve(value);
                };
                
                modalCancel.onclick = () => {
                    cleanup();
                    resolve(null);
                };
                
                modalInput.onkeydown = (e) => {
                    if (e.key === 'Enter') {
                        const value = modalInput.value;
                        cleanup();
                        resolve(value);
                    } else if (e.key === 'Escape') {
                        cleanup();
                        resolve(null);
                    }
                };
                
                // Enable focus trap
                document.addEventListener('keydown', handleTabKey);
            });
        }
        
        // Prompt for master password
        async function promptForMasterPassword() {
            const password = await showModal(
                'Master Password',
                'Enter your master password to unlock:',
                'Password',
                true
            );
            
            if (password && password.trim()) {
                const trimmed = password.trim();
                if (trimmed.length < 8) {
                    showStatus('‚ö† Password must be at least 8 characters', 'error');
                    return null;
                }
                resetInactivityTimer(); // Reset timer on successful password entry
                return trimmed;
            }
            return null;
        }
        
        // Initialize and load token on startup
        // Returns: { hasStoredToken: boolean, unlocked: boolean }
        async function loadStoredToken() {
            let tokenData = null;
            try {
                tokenData = localStorage.getItem('githubToken');
            } catch (e) {
                console.error('Failed to read from localStorage:', e);
                showStatus('‚ö† Cannot access storage. Check browser settings.', 'error', true);
                return { hasStoredToken: false, unlocked: false };
            }
            
            if (tokenData) {
                try {
                    const parsed = JSON.parse(tokenData);
                    const now = Date.now();
                    
                    // Check if token is expired
                    if (parsed.expiry && now < parsed.expiry) {
                        // Prompt for master password to decrypt
                        if (!AppState.getPassword()) {
                            AppState.setPassword(await promptForMasterPassword());
                            if (!AppState.getPassword()) {
                                showStatus('‚ö† Password required to unlock stored token', 'error');
                                return { hasStoredToken: true, unlocked: false };
                            }
                        }
                        
                        const decryptedToken = await decryptToken(parsed.token, AppState.getPassword());
                        if (!decryptedToken) {
                            // Decryption failed - wrong password
                            showStatus('‚ö† Incorrect password. Please reload and try again.', 'error');
                            AppState.clearCredentials();
                            // Keep token stored, allow retry
                            return { hasStoredToken: true, unlocked: false };
                        }
                        AppState.setToken(decryptedToken);
                        return { hasStoredToken: true, unlocked: true };
                    } else {
                        // Token expired, remove it
                        try {
                            localStorage.removeItem('githubToken');
                        } catch (e) {
                            console.error('Failed to remove expired token:', e);
                        }
                        showStatus('‚Ñπ Stored token expired', 'info');
                    }
                } catch (e) {
                    // Invalid format, remove it
                    try {
                        localStorage.removeItem('githubToken');
                    } catch (err) {
                        console.error('Failed to remove invalid token:', err);
                    }
                }
            }
            return { hasStoredToken: false, unlocked: false };
        }

        // Show status message
        function showStatus(message, type, persistent = false) {
            const statusEl = document.getElementById('status');
            statusEl.textContent = message;
            statusEl.className = `status ${type}`;
            statusEl.style.display = 'block';
            
            if (!persistent) {
                setTimeout(() => {
                    statusEl.style.display = 'none';
                }, STATUS_HIDE_DELAY);
            }
        }
        
        // Fix P1: Check if stored token has expired
        function isTokenExpired() {
            try {
                const tokenData = localStorage.getItem('githubToken');
                if (!tokenData) return false; // No token stored
                
                const parsed = JSON.parse(tokenData);
                const now = Date.now();
                
                if (parsed.expiry && now >= parsed.expiry) {
                    // Token has expired, clear it
                    try {
                        localStorage.removeItem('githubToken');
                    } catch (e) {
                        console.error('Failed to remove expired token:', e);
                    }
                    AppState.clearCredentials();
                    return true;
                }
                return false;
            } catch (e) {
                console.error('Error checking token expiry:', e);
                return false;
            }
        }

        // Fix P3: Unicode-safe base64 encoding
        function base64EncodeUnicode(str) {
            try {
                // Use TextEncoder for proper Unicode handling
                const bytes = new TextEncoder().encode(str);
                const binString = Array.from(bytes, (byte) => String.fromCodePoint(byte)).join('');
                return btoa(binString);
            } catch (e) {
                console.error('Base64 encode error:', e);
                // Fallback to regular btoa if TextEncoder fails
                return btoa(str);
            }
        }
        
        // Fix P3: Unicode-safe base64 decoding
        function base64DecodeUnicode(str) {
            try {
                // Decode from base64 then use TextDecoder
                const binString = atob(str);
                const bytes = Uint8Array.from(binString, (m) => m.codePointAt(0));
                return new TextDecoder().decode(bytes);
            } catch (e) {
                console.error('Base64 decode error:', e);
                // Fallback to regular atob if TextDecoder fails
                return atob(str);
            }
        }
        
        // Fix #2: Validate token against GitHub API
        async function validateToken(token) {
            try {
                const response = await fetch('https://api.github.com/user', {
                    headers: {
                        'Authorization': `Bearer ${token}`,
                        'Accept': 'application/vnd.github.v3+json'
                    }
                });
                
                if (response.ok) {
                    return { valid: true, error: null };
                } else if (response.status === 401) {
                    return { valid: false, error: 'Invalid token or token expired' };
                } else if (response.status === 403) {
                    const data = await response.json();
                    if (data.message && data.message.includes('rate limit')) {
                        return { valid: false, error: 'Rate limit exceeded. Please try again later.' };
                    }
                    return { valid: false, error: 'Access forbidden. Check token permissions.' };
                } else {
                    return { valid: false, error: `Validation failed: ${response.status}` };
                }
            } catch (error) {
                return { valid: false, error: 'Network error during validation' };
            }
        }
        
        // Prompt for token on first load
        async function promptForToken() {
            const token = await showModal(
                'GitHub Token',
                'Enter your GitHub Fine-grained Personal Access Token:',
                'ghp_...',
                false
            );
            if (token && token.trim()) {
                const tokenValue = token.trim();
                
                // Fix #2: Validate token before storing
                showStatus('‚è≥ Validating token...', 'info');
                const validation = await validateToken(tokenValue);
                
                if (!validation.valid) {
                    showStatus(`‚ö† ${validation.error}`, 'error', true);
                    return false;
                }
                
                // Prompt for master password if not already set
                if (!AppState.getPassword()) {
                    const password = await showModal(
                        'Create Master Password',
                        'Create a master password to encrypt your token (min 8 characters):',
                        'Password',
                        true
                    );
                    
                    if (!password) {
                        showStatus('‚ö† Password is required', 'error');
                        return false;
                    }
                    const trimmedPassword = password.trim();
                    if (trimmedPassword.length < 8) {
                        showStatus('‚ö† Password must be at least 8 characters', 'error');
                        return false;
                    }
                    
                    // Confirm password
                    const confirmPassword = await showModal(
                        'Confirm Password',
                        'Re-enter your master password to confirm:',
                        'Password',
                        true
                    );
                    
                    if (!confirmPassword) {
                        showStatus('‚ö† Password confirmation required', 'error');
                        return false;
                    }
                    if (confirmPassword.trim() !== trimmedPassword) {
                        showStatus('‚ö† Passwords do not match', 'error');
                        return false;
                    }
                    
                    AppState.setPassword(trimmedPassword);
                }
                
                const encrypted = await encryptToken(tokenValue, AppState.getPassword());
                
                if (!encrypted) {
                    showStatus('‚ö† Encryption failed', 'error');
                    AppState.setPassword(null);
                    return false;
                }
                
                // Only set token after successful encryption
                AppState.setToken(tokenValue);
                
                // Fix #3: Store token with error handling
                try {
                    const expiryDate = Date.now() + (TOKEN_EXPIRY_DAYS * 24 * 60 * 60 * 1000);
                    const tokenData = JSON.stringify({
                        token: encrypted,
                        expiry: expiryDate
                    });
                    localStorage.setItem('githubToken', tokenData);
                    showStatus(`‚úì Token validated and saved securely (expires in ${TOKEN_EXPIRY_DAYS} days)`, 'success');
                    return true;
                } catch (e) {
                    showStatus('‚ö† Failed to save token. Storage may be full or disabled.', 'error', true);
                    console.error('localStorage error:', e);
                    AppState.clearCredentials();
                    return false;
                }
            } else {
                showStatus('‚ö† Token is required to use this app', 'error');
                return false;
            }
        }

        // Pull data from GitHub
        async function pullFromGitHub() {
            // Fix P1: Check if token expired before operation
            if (isTokenExpired()) {
                showStatus('‚ö† Token expired. Please change token to continue.', 'error', true);
                return false;
            }
            
            resetInactivityTimer(); // Reset timer on API activity
            
            try {
                const url = `https://api.github.com/repos/${GITHUB_OWNER}/${GITHUB_REPO}/contents/${getGitHubPath()}`;
                
                const response = await fetch(url, {
                    headers: {
                        'Authorization': `Bearer ${AppState.getToken()}`,
                        'Accept': 'application/vnd.github.v3+json'
                    }
                });
                
                if (response.ok) {
                    const fileData = await response.json();
                    const content = base64DecodeUnicode(fileData.content.replace(/\s/g, ''));
                    AppState.setEvents(JSON.parse(content));
                    showStatus('‚úì Loaded data from GitHub', 'success');
                    return true;
                } else if (response.status === 404) {
                    // File doesn't exist yet, start with empty data
                    AppState.setEvents({});
                    showStatus('‚Ñπ File not found, starting fresh', 'info');
                    return true;
                } else if (response.status === 403) {
                    // Handle rate limiting using helper function
                    const data = await response.json();
                    if (data.message && data.message.includes('rate limit')) {
                        showStatus(handleRateLimitResponse(response), 'error', true);
                    } else {
                        showStatus('‚ö† Access forbidden. Check token permissions.', 'error', true);
                    }
                    return false;
                } else if (response.status === 401) {
                    showStatus('‚ö† Token expired or invalid. Please change token.', 'error', true);
                    return false;
                } else {
                    showStatus(`‚ö† Failed to load from GitHub (${response.status})`, 'error', true);
                    return false;
                }
            } catch (error) {
                console.error('GitHub pull error:', error);
                showStatus('‚ö† Network error loading from GitHub', 'error', true);
                return false;
            }
        }

        // Sync data to GitHub
        async function syncToGitHub() {
            // Fix P1: Check if token expired before operation
            if (isTokenExpired()) {
                showStatus('‚ö† Token expired. Please change token to continue.', 'error', true);
                return false;
            }
            
            resetInactivityTimer(); // Reset timer on API activity
            
            try {
                const url = `https://api.github.com/repos/${GITHUB_OWNER}/${GITHUB_REPO}/contents/${getGitHubPath()}`;
                
                // Get current file SHA
                const getResponse = await fetch(url, {
                    headers: {
                        'Authorization': `Bearer ${AppState.getToken()}`,
                        'Accept': 'application/vnd.github.v3+json'
                    }
                });
                
                let sha = null;
                if (getResponse.ok) {
                    const fileData = await getResponse.json();
                    sha = fileData.sha;
                } else if (getResponse.status === 403) {
                    // Handle rate limiting using helper function
                    const data = await getResponse.json();
                    if (data.message && data.message.includes('rate limit')) {
                        showStatus(handleRateLimitResponse(getResponse), 'error', true);
                        return false;
                    }
                }
                
                // Update file
                const content = base64EncodeUnicode(JSON.stringify(AppState.getEvents(), null, 2));
                const updateResponse = await fetch(url, {
                    method: 'PUT',
                    headers: {
                        'Authorization': `Bearer ${AppState.getToken()}`,
                        'Accept': 'application/vnd.github.v3+json',
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        message: 'Update calendar events',
                        content: content,
                        sha: sha
                    })
                });
                
                if (updateResponse.ok) {
                    showStatus('‚úì Successfully synced to GitHub', 'success');
                    return true;
                } else if (updateResponse.status === 403) {
                    // Handle rate limiting using helper function
                    const data = await updateResponse.json();
                    if (data.message && data.message.includes('rate limit')) {
                        showStatus(handleRateLimitResponse(updateResponse), 'error', true);
                    } else {
                        showStatus('‚ö† Access forbidden. Check token permissions.', 'error', true);
                    }
                    return false;
                } else if (updateResponse.status === 401) {
                    showStatus('‚ö† Token expired or invalid. Please change token.', 'error', true);
                    return false;
                } else {
                    const errorData = await updateResponse.json();
                    console.error('Sync failed:', errorData);
                    showStatus('‚ö† Sync failed: ' + (errorData.message || 'Unknown error'), 'error', true);
                    return false;
                }
            } catch (error) {
                showStatus('‚ö† Network error during sync: ' + error.message, 'error', true);
                console.error('GitHub sync error:', error);
                return false;
            }
        }

        // Add test item
        async function addTestItem() {
            if (!AppState.getToken()) {
                showStatus('‚ö† Please authenticate first', 'error', true);
                return;
            }
            
            resetInactivityTimer(); // Reset timer on user action
            
            const btnAdd = document.getElementById('btnAddItem');
            const btnChange = document.getElementById('btnChangeToken');
            
            // Disable buttons during operation
            btnAdd.disabled = true;
            btnChange.disabled = true;
            
            try {
                showStatus('‚è≥ Adding item...', 'info');
                
                // Pull latest data first
                const pulled = await pullFromGitHub();
                if (!pulled) {
                    // Fix #5: Better error recovery with actionable message
                    showStatus('‚ö† Failed to load data. Please check your connection or token.', 'error', true);
                    return;
                }
                
                // Add new item with current date and time
                const now = new Date();
                const dateKey = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')}`;
                const timeString = `${String(now.getHours()).padStart(2, '0')}:${String(now.getMinutes()).padStart(2, '0')}`;
                
                const events = AppState.getEvents();
                if (!events[dateKey]) {
                    events[dateKey] = [];
                }
                
                events[dateKey].push({
                    name: 'Test Item ' + Date.now(),
                    time: timeString
                });
                
                // Sync to GitHub
                const synced = await syncToGitHub();
                if (!synced) {
                    // Roll back the change if sync failed
                    const lastIndex = events[dateKey].length - 1;
                    events[dateKey].splice(lastIndex, 1);
                    if (events[dateKey].length === 0) {
                        delete events[dateKey];
                    }
                    showStatus('‚ö† Failed to sync. Item not added.', 'error', true);
                }
            } finally {
                // Re-enable buttons
                btnAdd.disabled = false;
                btnChange.disabled = false;
            }
        }

        // Change token
        async function changeToken() {
            resetInactivityTimer(); // Reset timer on user action
            
            // Clear existing credentials to force new password creation
            const oldToken = AppState.getToken();
            const oldPassword = AppState.getPassword();
            
            AppState.clearCredentials();
            
            const success = await promptForToken();
            
            if (!success) {
                // Restore old credentials if user cancels
                AppState.setToken(oldToken);
                AppState.setPassword(oldPassword);
                showStatus('‚ö† Token change cancelled', 'info');
            } else {
                // Re-enable Add button if it was disabled
                document.getElementById('btnAddItem').disabled = false;
                document.getElementById('btnChangeToken').textContent = 'Change Token';
                // Note: Old credentials will be garbage collected eventually
                // JavaScript doesn't allow forcing memory clearing
                showStatus('‚úì Token and password updated successfully', 'success');
            }
        }
        
        // Initialize
        async function init() {
            // Load stored token first
            const tokenStatus = await loadStoredToken();
            
            // If stored token exists but wasn't unlocked, don't proceed
            if (tokenStatus.hasStoredToken && !tokenStatus.unlocked) {
                showStatus('‚ö† Please reload and enter correct password', 'error', true);
                return;
            }
            
            // Only prompt for new token if no stored token exists
            if (!AppState.getToken() && !tokenStatus.hasStoredToken) {
                const hasToken = await promptForToken();
                if (!hasToken) {
                    showStatus('‚ö† Cannot proceed without authentication', 'error', true);
                    return;
                }
            }
            
            // Load existing data only if we have a valid token
            if (AppState.getToken()) {
                await pullFromGitHub();
            }
        }
        
        // Clear references when page unloads (garbage collector will handle actual cleanup)
        window.addEventListener('beforeunload', () => {
            clearTimeout(AppState.getInactivityTimer());
            AppState.clearCredentials();
        });

        // Event listeners
        document.getElementById('btnAddItem').addEventListener('click', addTestItem);
        document.getElementById('btnChangeToken').addEventListener('click', changeToken);

        // Run on page load
        init();
    </script>
</body>
</html>
